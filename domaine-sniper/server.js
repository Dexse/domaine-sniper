const express = require('express');
const cors = require('cors');
const path = require('path');
const Database = require('./database');
const OVHClient = require('./ovhClient');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Initialisation diff√©r√©e pour Railway
let db;
let ovhClient;

// Fonction d'initialisation
function initializeServices() {
  try {
    // V√©rification des variables d'environnement OVH
    const requiredEnvVars = ['OVH_APP_KEY', 'OVH_APP_SECRET', 'OVH_CONSUMER_KEY'];
    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
    
    if (missingVars.length > 0) {
      console.error('‚ùå Variables d\'environnement OVH manquantes:');
      missingVars.forEach(varName => {
        console.error(`   - ${varName}`);
      });
      console.error('\nüí° Veuillez configurer ces variables dans Railway');
      return false;
    }
    
    db = new Database();
    ovhClient = new OVHClient();
    console.log('‚úÖ Services initialis√©s avec succ√®s');
    return true;
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'initialisation:', error.message);
    return false;
  }
}

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Variables globales pour le monitoring
let isMonitoring = false;
let monitoringInterval = null;

// Fonction pour logger avec base de donn√©es
async function logMessage(level, message, domain = null) {
  console.log(`[${new Date().toLocaleString()}] ${level.toUpperCase()}: ${message}`);
  try {
    await db.addLog(level, message, domain);
  } catch (error) {
    console.error('Erreur lors de l\'ajout du log:', error);
  }
}

// Fonction de monitoring des domaines
async function monitorDomains() {
  try {
    const domains = await db.getAllDomains();
    const activeDomains = domains.filter(d => d.monitoring_enabled);
    
    if (activeDomains.length === 0) {
      await logMessage('info', 'Aucun domaine actif √† surveiller');
      return;
    }

    await logMessage('info', `V√©rification de ${activeDomains.length} domaine(s)...`);

    for (const domain of activeDomains) {
      try {
        // D'abord r√©cup√©rer les informations d'expiration
        const expirationInfo = await ovhClient.getDomainExpirationInfo(domain.domain);
        if (expirationInfo) {
          await db.updateDomainExpirationInfo(
            domain.id,
            expirationInfo.expiryDate,
            expirationInfo.estimatedReleaseDate,
            expirationInfo.daysUntilExpiry,
            expirationInfo.registrar
          );
        }
        
        const isAvailable = await ovhClient.isDomainAvailable(domain.domain);
        
        // Enregistrer la v√©rification
        await db.addDomainCheck(domain.id, isAvailable ? 'available' : 'unavailable', isAvailable);
        
        if (isAvailable) {
          await logMessage('success', `üéØ DOMAINE DISPONIBLE: ${domain.domain}`, domain.domain);
          await db.updateDomainStatus(domain.id, 'available');
          
          // Achat automatique si activ√©
          if (domain.auto_purchase_enabled) {
            await logMessage('info', `Tentative d'achat automatique pour ${domain.domain}...`, domain.domain);
            
            const purchaseResult = await ovhClient.purchaseDomain(domain.domain);
            
            if (purchaseResult.success) {
              await logMessage('success', `‚úÖ Achat r√©ussi pour ${domain.domain}! ID: ${purchaseResult.orderId}`, domain.domain);
              await db.addPurchase(domain.id, domain.domain, purchaseResult.orderId, 'completed');
              await db.updateDomainStatus(domain.id, 'purchased');
            } else {
              await logMessage('error', `‚ùå √âchec de l'achat pour ${domain.domain}: ${purchaseResult.error}`, domain.domain);
              await db.addPurchase(domain.id, domain.domain, null, 'failed', null, purchaseResult.error);
            }
          }
        } else {
          await db.updateDomainStatus(domain.id, 'unavailable');
          await logMessage('info', `${domain.domain} - Non disponible`, domain.domain);
        }
        
        // D√©lai entre les v√©rifications
        await new Promise(resolve => setTimeout(resolve, 2000));
        
      } catch (error) {
        await logMessage('error', `Erreur lors de la v√©rification de ${domain.domain}: ${error.message}`, domain.domain);
        await db.addDomainCheck(domain.id, 'error', false, error.message);
        await db.updateDomainStatus(domain.id, 'error');
      }
    }
    
    await logMessage('info', 'V√©rification termin√©e');
  } catch (error) {
    await logMessage('error', `Erreur g√©n√©rale du monitoring: ${error.message}`);
  }
}

// Routes API

// Dashboard - Statistiques g√©n√©rales
app.get('/api/dashboard', async (req, res) => {
  try {
    if (!db || !ovhClient) {
      return res.status(503).json({ error: 'Services non initialis√©s. V√©rifiez les variables d\'environnement.' });
    }
    
    const domains = await db.getAllDomains();
    const purchases = await db.getAllPurchases();
    const logs = await db.getRecentLogs(10);
    
    // R√©cup√©rer le solde OVH
    const balanceInfo = await ovhClient.getAccountBalance();
    
    const stats = {
      totalDomains: domains.length,
      activeDomains: domains.filter(d => d.monitoring_enabled).length,
      availableDomains: domains.filter(d => d.status === 'available').length,
      purchasedDomains: purchases.filter(p => p.status === 'completed').length,
      isMonitoring,
      ovhBalance: balanceInfo,
      lastCheck: domains.length > 0 ? Math.max(...domains.map(d => new Date(d.last_check || 0).getTime())) : null
    };
    
    res.json({ stats, recentLogs: logs });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Gestion des domaines
app.get('/api/domains', async (req, res) => {
  try {
    if (!db) {
      return res.status(503).json({ error: 'Base de donn√©es non initialis√©e' });
    }
    
    const domains = await db.getAllDomains();
    res.json(domains);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/domains', async (req, res) => {
  try {
    if (!db) {
      return res.status(503).json({ error: 'Base de donn√©es non initialis√©e' });
    }
    
    const { domain, monitoringEnabled = true, autoPurchaseEnabled = false } = req.body;
    
    if (!domain) {
      return res.status(400).json({ error: 'Le nom de domaine est requis' });
    }
    
    const id = await db.addDomain(domain, monitoringEnabled, autoPurchaseEnabled);
    await logMessage('info', `Nouveau domaine ajout√©: ${domain}`);
    
    res.json({ id, message: 'Domaine ajout√© avec succ√®s' });
  } catch (error) {
    if (error.message.includes('UNIQUE constraint failed')) {
      res.status(400).json({ error: 'Ce domaine existe d√©j√†' });
    } else {
      res.status(500).json({ error: error.message });
    }
  }
});

app.put('/api/domains/:id', async (req, res) => {
  try {
    if (!db) {
      return res.status(503).json({ error: 'Base de donn√©es non initialis√©e' });
    }
    
    const { id } = req.params;
    const { monitoringEnabled, autoPurchaseEnabled } = req.body;
    
    await db.updateDomainSettings(id, monitoringEnabled, autoPurchaseEnabled);
    await logMessage('info', `Param√®tres mis √† jour pour le domaine ID: ${id}`);
    
    res.json({ message: 'Param√®tres mis √† jour' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/domains/:id', async (req, res) => {
  try {
    if (!db) {
      return res.status(503).json({ error: 'Base de donn√©es non initialis√©e' });
    }
    
    const { id } = req.params;
    await db.deleteDomain(id);
    await logMessage('info', `Domaine supprim√© ID: ${id}`);
    
    res.json({ message: 'Domaine supprim√©' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Contr√¥le du monitoring
app.post('/api/monitoring/start', async (req, res) => {
  try {
    if (!db || !ovhClient) {
      return res.status(503).json({ error: 'Services non initialis√©s' });
    }
    
    if (isMonitoring) {
      return res.json({ message: 'Le monitoring est d√©j√† actif' });
    }
    
    isMonitoring = true;
    await logMessage('success', 'üöÄ D√©marrage du monitoring automatique');
    
    // Premi√®re v√©rification imm√©diate
    await monitorDomains();
    
    // Programmer les v√©rifications p√©riodiques (60 secondes)
    monitoringInterval = setInterval(monitorDomains, 60000);
    
    res.json({ message: 'Monitoring d√©marr√©' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/monitoring/stop', async (req, res) => {
  try {
    if (!db) {
      return res.status(503).json({ error: 'Base de donn√©es non initialis√©e' });
    }
    
    isMonitoring = false;
    if (monitoringInterval) {
      clearInterval(monitoringInterval);
      monitoringInterval = null;
    }
    
    await logMessage('warning', 'üõë Arr√™t du monitoring automatique');
    res.json({ message: 'Monitoring arr√™t√©' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/monitoring/check', async (req, res) => {
  try {
    if (!db || !ovhClient) {
      return res.status(503).json({ error: 'Services non initialis√©s' });
    }
    
    await logMessage('info', 'üîç V√©rification manuelle d√©clench√©e');
    await monitorDomains();
    res.json({ message: 'V√©rification effectu√©e' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Analytics
app.get('/api/analytics', async (req, res) => {
  try {
    if (!db) {
      return res.status(503).json({ error: 'Base de donn√©es non initialis√©e' });
    }
    
    const { startDate, endDate } = req.query;
    const start = startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    const end = endDate || new Date().toISOString().split('T')[0];
    
    const analyticsData = await db.getAnalyticsData(start, end);
    res.json(analyticsData);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Achats
app.get('/api/purchases', async (req, res) => {
  try {
    if (!db) {
      return res.status(503).json({ error: 'Base de donn√©es non initialis√©e' });
    }
    
    const purchases = await db.getAllPurchases();
    res.json(purchases);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Logs
app.get('/api/logs', async (req, res) => {
  try {
    if (!db) {
      return res.status(503).json({ error: 'Base de donn√©es non initialis√©e' });
    }
    
    const logs = await db.getRecentLogs(100);
    res.json(logs);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Routes pour servir les pages
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Test de connexion OVH
app.get('/api/test-ovh', async (req, res) => {
  try {
    if (!ovhClient) {
      return res.status(503).json({ error: 'Client OVH non initialis√©' });
    }
    
    console.log('üîç D√©but du test de connexion OVH...');
    console.log('üìã Variables d\'environnement:', {
      OVH_APP_KEY: process.env.OVH_APP_KEY ? '‚úÖ D√©fini' : '‚ùå Manquant',
      OVH_APP_SECRET: process.env.OVH_APP_SECRET ? '‚úÖ D√©fini' : '‚ùå Manquant',
      OVH_CONSUMER_KEY: process.env.OVH_CONSUMER_KEY ? '‚úÖ D√©fini' : '‚ùå Manquant'
    });
    
    const connectionTest = await ovhClient.testConnection();
    console.log('üîó R√©sultat test connexion:', connectionTest);
    
    const balanceInfo = await ovhClient.getAccountBalance();
    console.log('üí∞ R√©sultat test solde:', balanceInfo);
    
    res.json({
      connection: connectionTest,
      balance: balanceInfo,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('‚ùå Erreur compl√®te du test OVH:', error);
    res.status(500).json({ 
      error: error.message,
      connection: { success: false, error: error.message },
      balance: { balance: null, error: error.message }
    });
  }
});

app.get('/analytics', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'analytics.html'));
});

app.get('/purchases', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'purchases.html'));
});

// D√©marrage du serveur
app.listen(PORT, async () => {
  console.log(`üåê Serveur d√©marr√© sur le port ${PORT}`);
  
  // Initialiser les services apr√®s le d√©marrage du serveur
  const initialized = initializeServices();
  
  if (initialized) {
    await logMessage('success', `üåê Domaine Sniper SaaS d√©marr√© sur le port ${PORT}`);
  } else {
    console.log('‚ö†Ô∏è Serveur d√©marr√© mais services non initialis√©s - v√©rifiez les variables d\'environnement');
  }
  
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üéØ DOMAINE SNIPER SAAS                   ‚ïë
‚ïë                                                              ‚ïë
‚ïë  Status: ${initialized ? '‚úÖ Pr√™t' : '‚ö†Ô∏è Variables manquantes'}                                    ‚ïë
‚ïë                                                              ‚ïë
‚ïë  Port: ${PORT}                                                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `);
});

// Gestion propre de l'arr√™t
process.on('SIGINT', async () => {
  console.log('\nüõë Arr√™t de Domaine Sniper SaaS...');
  if (monitoringInterval) {
    clearInterval(monitoringInterval);
  }
  if (db) {
    db.close();
  }
  process.exit(0);
});
